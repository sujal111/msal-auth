{"ast":null,"code":"/*! @azure/msal-common v11.0.0 2023-03-07 */\n'use strict';\n\nimport { CredentialType, CacheType, Constants, Separators, AuthenticationScheme } from '../../utils/Constants.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Base type for credentials to be stored in the cache: eg: ACCESS_TOKEN, ID_TOKEN etc\r\n *\r\n * Key:Value Schema:\r\n *\r\n * Key: <home_account_id*>-<environment>-<credential_type>-<client_id>-<realm*>-<target*>-<requestedClaims*>-<scheme*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n *      tokenType: Matches the authentication scheme for which the token was issued (i.e. Bearer or pop)\r\n *      requestedClaimsHash: Matches the SHA 256 hash of the claims object included in the token request\r\n *      userAssertionHash: Matches the SHA 256 hash of the obo_assertion for the OBO flow\r\n * }\r\n */\nvar CredentialEntity = /** @class */function () {\n  function CredentialEntity() {}\n  /**\r\n   * Initializes a map with credential {CredentialType} regular expressions.\r\n   */\n  CredentialEntity._initRegex = function () {\n    var separator = Separators.CACHE_KEY_SEPARATOR;\n    CredentialEntity.credentialRegexMap = new Map();\n    for (var _i = 0, _a = Object.keys(CredentialType); _i < _a.length; _i++) {\n      var credKey = _a[_i];\n      var credVal = CredentialType[credKey].toLowerCase();\n      try {\n        // Verify credential type is preceded by a valid host name (environment) using lookbehind\n        CredentialEntity.credentialRegexMap.set(CredentialType[credKey], new RegExp(\"(?<=\" + separator + CredentialEntity.credentialDomainRegex + \")\" + separator + credVal + separator));\n      } catch (err) {\n        // Lookbehind is not supported (Safari or older versions of IE) - removing it\n        CredentialEntity.credentialRegexMap.set(CredentialType[credKey], new RegExp(\"\" + separator + CredentialEntity.credentialDomainRegex + separator + credVal + separator));\n      }\n    }\n  };\n  /**\r\n   * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n   */\n  CredentialEntity.prototype.generateAccountId = function () {\n    return CredentialEntity.generateAccountIdForCacheKey(this.homeAccountId, this.environment);\n  };\n  /**\r\n   * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\r\n   */\n  CredentialEntity.prototype.generateCredentialId = function () {\n    return CredentialEntity.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);\n  };\n  /**\r\n   * Generate target key component as per schema: <target>\r\n   */\n  CredentialEntity.prototype.generateTarget = function () {\n    return CredentialEntity.generateTargetForCacheKey(this.target);\n  };\n  /**\r\n   * generates credential key\r\n   */\n  CredentialEntity.prototype.generateCredentialKey = function () {\n    return CredentialEntity.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash);\n  };\n  /**\r\n   * returns the type of the cache (in this case credential)\r\n   */\n  CredentialEntity.prototype.generateType = function () {\n    switch (this.credentialType) {\n      case CredentialType.ID_TOKEN:\n        return CacheType.ID_TOKEN;\n      case CredentialType.ACCESS_TOKEN:\n      case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n        return CacheType.ACCESS_TOKEN;\n      case CredentialType.REFRESH_TOKEN:\n        return CacheType.REFRESH_TOKEN;\n      default:\n        {\n          throw ClientAuthError.createUnexpectedCredentialTypeError();\n        }\n    }\n  };\n  /**\r\n   * helper function to return `CredentialType`\r\n   * @param key\r\n   */\n  CredentialEntity.getCredentialType = function (key) {\n    var _a;\n    for (var _i = 0, _b = Object.keys(CredentialType); _i < _b.length; _i++) {\n      var credKey = _b[_i];\n      if ((_a = this.credentialRegexMap.get(CredentialType[credKey])) === null || _a === void 0 ? void 0 : _a.test(key.toLowerCase())) {\n        return CredentialType[credKey];\n      }\n    }\n    return Constants.NOT_DEFINED;\n  };\n  /**\r\n   * generates credential key\r\n   * <home_account_id*>-\\<environment>-<credential_type>-<client_id>-<realm\\*>-<target\\*>-<scheme\\*>\r\n   */\n  CredentialEntity.generateCredentialCacheKey = function (homeAccountId, environment, credentialType, clientId, realm, target, familyId, tokenType, requestedClaimsHash) {\n    var credentialKey = [this.generateAccountIdForCacheKey(homeAccountId, environment), this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId), this.generateTargetForCacheKey(target), this.generateClaimsHashForCacheKey(requestedClaimsHash), this.generateSchemeForCacheKey(tokenType)];\n    return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * generates Account Id for keys\r\n   * @param homeAccountId\r\n   * @param environment\r\n   */\n  CredentialEntity.generateAccountIdForCacheKey = function (homeAccountId, environment) {\n    var accountId = [homeAccountId, environment];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Generates Credential Id for keys\r\n   * @param credentialType\r\n   * @param realm\r\n   * @param clientId\r\n   * @param familyId\r\n   */\n  CredentialEntity.generateCredentialIdForCacheKey = function (credentialType, clientId, realm, familyId) {\n    var clientOrFamilyId = credentialType === CredentialType.REFRESH_TOKEN ? familyId || clientId : clientId;\n    var credentialId = [credentialType, clientOrFamilyId, realm || Constants.EMPTY_STRING];\n    return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Generate target key component as per schema: <target>\r\n   */\n  CredentialEntity.generateTargetForCacheKey = function (scopes) {\n    return (scopes || Constants.EMPTY_STRING).toLowerCase();\n  };\n  /**\r\n   * Generate requested claims key component as per schema: <requestedClaims>\r\n   */\n  CredentialEntity.generateClaimsHashForCacheKey = function (requestedClaimsHash) {\n    return (requestedClaimsHash || Constants.EMPTY_STRING).toLowerCase();\n  };\n  /**\r\n   * Generate scheme key componenet as per schema: <scheme>\r\n   */\n  CredentialEntity.generateSchemeForCacheKey = function (tokenType) {\n    /*\r\n     * PoP Tokens and SSH certs include scheme in cache key\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n    return tokenType && tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? tokenType.toLowerCase() : Constants.EMPTY_STRING;\n  };\n  /*\r\n   * Match host names like \"login.microsoftonline.com\", \"https://accounts.google.com:4000\", https://localhost:5000,\r\n   * \"login.microsoftonline.com/common\", \"login.microsoftonline.com:4000/common\", etc\r\n   */\n  CredentialEntity.credentialDomainRegex = \"(https?:\\\\/\\\\/)?((([\\\\w-]+\\\\.)*([\\\\w-]{1,63})(\\\\.(\\\\w{2,63})))|(localhost))(\\\\:[0-9]{4,5})?(\\\\/[\\\\w-]+)?\";\n  return CredentialEntity;\n}();\nCredentialEntity._initRegex();\nexport { CredentialEntity };","map":{"version":3,"names":["CredentialEntity","_initRegex","separator","Separators","CACHE_KEY_SEPARATOR","credentialRegexMap","Map","_i","_a","Object","keys","CredentialType","length","credKey","credVal","toLowerCase","set","RegExp","credentialDomainRegex","err","prototype","generateAccountId","generateAccountIdForCacheKey","homeAccountId","environment","generateCredentialId","generateCredentialIdForCacheKey","credentialType","clientId","realm","familyId","generateTarget","generateTargetForCacheKey","target","generateCredentialKey","generateCredentialCacheKey","tokenType","requestedClaimsHash","generateType","ID_TOKEN","CacheType","ACCESS_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","REFRESH_TOKEN","ClientAuthError","createUnexpectedCredentialTypeError","getCredentialType","key","_b","get","test","Constants","NOT_DEFINED","credentialKey","generateClaimsHashForCacheKey","generateSchemeForCacheKey","join","accountId","clientOrFamilyId","credentialId","EMPTY_STRING","scopes","AuthenticationScheme","BEARER"],"sources":["/Users/sujal/Desktop/MSAL/msal-react-tutorial/node_modules/@azure/msal-common/src/cache/entities/CredentialEntity.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Separators, CredentialType, CacheType, Constants, AuthenticationScheme } from \"../../utils/Constants\";\nimport { ClientAuthError } from \"../../error/ClientAuthError\";\n\n/**\n * Base type for credentials to be stored in the cache: eg: ACCESS_TOKEN, ID_TOKEN etc\n *\n * Key:Value Schema:\n *\n * Key: <home_account_id*>-<environment>-<credential_type>-<client_id>-<realm*>-<target*>-<requestedClaims*>-<scheme*>\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\n *      clientId: client ID of the application\n *      secret: Actual credential as a string\n *      familyId: Family ID identifier, usually only used for refresh tokens\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\n *      tokenType: Matches the authentication scheme for which the token was issued (i.e. Bearer or pop)\n *      requestedClaimsHash: Matches the SHA 256 hash of the claims object included in the token request\n *      userAssertionHash: Matches the SHA 256 hash of the obo_assertion for the OBO flow\n * }\n */\nexport class CredentialEntity {\n    homeAccountId: string;\n    environment: string;\n    credentialType: CredentialType;\n    clientId: string;\n    secret: string;\n    familyId?: string;\n    realm?: string;\n    target?: string;\n    userAssertionHash?: string;\n    tokenType?: AuthenticationScheme;\n    keyId?: string;\n    requestedClaimsHash?: string;\n\n    /*\n     * Match host names like \"login.microsoftonline.com\", \"https://accounts.google.com:4000\", https://localhost:5000,\n     * \"login.microsoftonline.com/common\", \"login.microsoftonline.com:4000/common\", etc\n     */\n    private static credentialDomainRegex = \"(https?:\\\\/\\\\/)?((([\\\\w-]+\\\\.)*([\\\\w-]{1,63})(\\\\.(\\\\w{2,63})))|(localhost))(\\\\:[0-9]{4,5})?(\\\\/[\\\\w-]+)?\";\n    // Maps {CredentialType} to the corresponding regular expression.\n    private static credentialRegexMap: Map<CredentialType, RegExp>;\n\n    /**\n     * Initializes a map with credential {CredentialType} regular expressions.\n     */\n    static _initRegex(): void {\n        const separator = Separators.CACHE_KEY_SEPARATOR;\n        CredentialEntity.credentialRegexMap = new Map<CredentialType, RegExp>();\n        for (const credKey of Object.keys(CredentialType)) {\n            const credVal = CredentialType[credKey].toLowerCase();\n\n            try {\n                // Verify credential type is preceded by a valid host name (environment) using lookbehind\n                CredentialEntity.credentialRegexMap.set(\n                    CredentialType[credKey],\n                    new RegExp(`(?<=${separator}${CredentialEntity.credentialDomainRegex})${separator}${credVal}${separator}`));\n            } catch (err) {\n                // Lookbehind is not supported (Safari or older versions of IE) - removing it\n                CredentialEntity.credentialRegexMap.set(\n                    CredentialType[credKey],\n                    new RegExp(`${separator}${CredentialEntity.credentialDomainRegex}${separator}${credVal}${separator}`));\n            }\n        }\n    }\n\n    /**\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\n     */\n    generateAccountId(): string {\n        return CredentialEntity.generateAccountIdForCacheKey(this.homeAccountId, this.environment);\n    }\n\n    /**\n     * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\n     */\n    generateCredentialId(): string {\n        return CredentialEntity.generateCredentialIdForCacheKey(\n            this.credentialType,\n            this.clientId,\n            this.realm,\n            this.familyId\n        );\n    }\n\n    /**\n     * Generate target key component as per schema: <target>\n     */\n    generateTarget(): string {\n        return CredentialEntity.generateTargetForCacheKey(this.target);\n    }\n\n    /**\n     * generates credential key\n     */\n    generateCredentialKey(): string {\n        return CredentialEntity.generateCredentialCacheKey(\n            this.homeAccountId,\n            this.environment,\n            this.credentialType,\n            this.clientId,\n            this.realm,\n            this.target,\n            this.familyId,\n            this.tokenType,\n            this.requestedClaimsHash,\n        );\n    }\n\n    /**\n     * returns the type of the cache (in this case credential)\n     */\n    generateType(): number {\n        switch (this.credentialType) {\n            case CredentialType.ID_TOKEN:\n                return CacheType.ID_TOKEN;\n            case CredentialType.ACCESS_TOKEN:\n            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                return CacheType.ACCESS_TOKEN;\n            case CredentialType.REFRESH_TOKEN:\n                return CacheType.REFRESH_TOKEN;\n            default: {\n                throw ClientAuthError.createUnexpectedCredentialTypeError();\n            }\n        }\n    }\n\n    /**\n     * helper function to return `CredentialType`\n     * @param key\n     */\n    static getCredentialType(key: string): string {\n        for (const credKey of Object.keys(CredentialType)) {\n            if (this.credentialRegexMap.get(CredentialType[credKey])?.test(key.toLowerCase())) {\n                return CredentialType[credKey];\n            }\n        }\n\n        return Constants.NOT_DEFINED;\n    }\n\n    /**\n     * generates credential key\n     * <home_account_id*>-\\<environment>-<credential_type>-<client_id>-<realm\\*>-<target\\*>-<scheme\\*>\n     */\n    static generateCredentialCacheKey(\n        homeAccountId: string,\n        environment: string,\n        credentialType: CredentialType,\n        clientId: string,\n        realm?: string,\n        target?: string,\n        familyId?: string,\n        tokenType?: AuthenticationScheme,\n        requestedClaimsHash?: string\n    ): string {\n        const credentialKey = [\n            this.generateAccountIdForCacheKey(homeAccountId, environment),\n            this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId),\n            this.generateTargetForCacheKey(target),\n            this.generateClaimsHashForCacheKey(requestedClaimsHash),\n            this.generateSchemeForCacheKey(tokenType)\n        ];\n\n        return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n\n    /**\n     * generates Account Id for keys\n     * @param homeAccountId\n     * @param environment\n     */\n    private static generateAccountIdForCacheKey(\n        homeAccountId: string,\n        environment: string\n    ): string {\n        const accountId: Array<string> = [homeAccountId, environment];\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n\n    /**\n     * Generates Credential Id for keys\n     * @param credentialType\n     * @param realm\n     * @param clientId\n     * @param familyId\n     */\n    private static generateCredentialIdForCacheKey(\n        credentialType: CredentialType,\n        clientId: string,\n        realm?: string,\n        familyId?: string\n    ): string {\n        const clientOrFamilyId =\n            credentialType === CredentialType.REFRESH_TOKEN\n                ? familyId || clientId\n                : clientId;\n        const credentialId: Array<string> = [\n            credentialType,\n            clientOrFamilyId,\n            realm || Constants.EMPTY_STRING,\n        ];\n\n        return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n\n    /**\n     * Generate target key component as per schema: <target>\n     */\n    private static generateTargetForCacheKey(scopes?: string): string {\n        return (scopes || Constants.EMPTY_STRING).toLowerCase();\n    }\n\n    /**\n     * Generate requested claims key component as per schema: <requestedClaims>\n     */\n    private static generateClaimsHashForCacheKey(requestedClaimsHash?: string): string {\n        return(requestedClaimsHash || Constants.EMPTY_STRING).toLowerCase();\n    }\n\n    /**\n     * Generate scheme key componenet as per schema: <scheme>\n     */\n    private static generateSchemeForCacheKey(tokenType?: string): string {\n        /*\n         * PoP Tokens and SSH certs include scheme in cache key\n         * Cast to lowercase to handle \"bearer\" from ADFS\n         */\n        return (tokenType && tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? tokenType.toLowerCase() : Constants.EMPTY_STRING;\n    }\n}\n\nCredentialEntity._initRegex();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}