{"ast":null,"code":"/*! @azure/msal-browser v2.34.0 2023-03-07 */\n'use strict';\n\nimport { __extends, __spread, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { AccountEntity, CacheManager, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, Constants, PersistentCacheKeys, ClientAuthError, ThrottlingEntity, StringUtils, ProtocolUtils, CcsCredentialType, IdToken, DEFAULT_CRYPTO_IMPLEMENTATION } from '@azure/msal-common';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { BrowserCacheLocation, InMemoryCacheKeys, TemporaryCacheKeys } from '../utils/BrowserConstants.js';\nimport { BrowserStorage } from './BrowserStorage.js';\nimport { MemoryStorage } from './MemoryStorage.js';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\nvar BrowserCacheManager = /** @class */function (_super) {\n  __extends(BrowserCacheManager, _super);\n  function BrowserCacheManager(clientId, cacheConfig, cryptoImpl, logger) {\n    var _this = _super.call(this, clientId, cryptoImpl) || this;\n    // Cookie life calculation (hours * minutes * seconds * ms)\n    _this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n    _this.cacheConfig = cacheConfig;\n    _this.logger = logger;\n    _this.internalStorage = new MemoryStorage();\n    _this.browserStorage = _this.setupBrowserStorage(_this.cacheConfig.cacheLocation);\n    _this.temporaryCacheStorage = _this.setupTemporaryCacheStorage(_this.cacheConfig.cacheLocation);\n    // Migrate any cache entries from older versions of MSAL.\n    _this.migrateCacheEntries();\n    return _this;\n  }\n  /**\r\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n   * @param cacheLocation\r\n   */\n  BrowserCacheManager.prototype.setupBrowserStorage = function (cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n          return new BrowserStorage(cacheLocation);\n        } catch (e) {\n          this.logger.verbose(e);\n          break;\n        }\n    }\n    this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n    return new MemoryStorage();\n  };\n  /**\r\n   *\r\n   * @param cacheLocation\r\n   */\n  BrowserCacheManager.prototype.setupTemporaryCacheStorage = function (cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n          return new BrowserStorage(BrowserCacheLocation.SessionStorage);\n        } catch (e) {\n          this.logger.verbose(e);\n          return this.internalStorage;\n        }\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        return this.internalStorage;\n    }\n  };\n  /**\r\n   * Migrate all old cache entries to new schema. No rollback supported.\r\n   * @param storeAuthStateInCookie\r\n   */\n  BrowserCacheManager.prototype.migrateCacheEntries = function () {\n    var _this = this;\n    var idTokenKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ID_TOKEN;\n    var clientInfoKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.CLIENT_INFO;\n    var errorKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR;\n    var errorDescKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR_DESC;\n    var idTokenValue = this.browserStorage.getItem(idTokenKey);\n    var clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n    var errorValue = this.browserStorage.getItem(errorKey);\n    var errorDescValue = this.browserStorage.getItem(errorDescKey);\n    var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    var keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach(function (cacheKey, index) {\n      return _this.migrateCacheEntry(cacheKey, values[index]);\n    });\n  };\n  /**\r\n   * Utility function to help with migration.\r\n   * @param newKey\r\n   * @param value\r\n   * @param storeAuthStateInCookie\r\n   */\n  BrowserCacheManager.prototype.migrateCacheEntry = function (newKey, value) {\n    if (value) {\n      this.setTemporaryCache(newKey, value, true);\n    }\n  };\n  /**\r\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n   * @param input\r\n   */\n  BrowserCacheManager.prototype.validateAndParseJson = function (jsonValue) {\n    try {\n      var parsedJson = JSON.parse(jsonValue);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  };\n  /**\r\n   * fetches the entry from the browser storage based off the key\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.getItem = function (key) {\n    return this.browserStorage.getItem(key);\n  };\n  /**\r\n   * sets the entry in the browser storage\r\n   * @param key\r\n   * @param value\r\n   */\n  BrowserCacheManager.prototype.setItem = function (key, value) {\n    this.browserStorage.setItem(key, value);\n  };\n  /**\r\n   * fetch the account entity from the platform cache\r\n   * @param accountKey\r\n   */\n  BrowserCacheManager.prototype.getAccount = function (accountKey) {\n    var account = this.getItem(accountKey);\n    if (!account) {\n      return null;\n    }\n    var parsedAccount = this.validateAndParseJson(account);\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      return null;\n    }\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  };\n  /**\r\n   * set account entity in the platform cache\r\n   * @param key\r\n   * @param value\r\n   */\n  BrowserCacheManager.prototype.setAccount = function (account) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    var key = account.generateAccountKey();\n    this.setItem(key, JSON.stringify(account));\n  };\n  /**\r\n   * generates idToken entity from a string\r\n   * @param idTokenKey\r\n   */\n  BrowserCacheManager.prototype.getIdTokenCredential = function (idTokenKey) {\n    var value = this.getItem(idTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      return null;\n    }\n    var parsedIdToken = this.validateAndParseJson(value);\n    if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n  };\n  /**\r\n   * set IdToken credential to the platform cache\r\n   * @param idToken\r\n   */\n  BrowserCacheManager.prototype.setIdTokenCredential = function (idToken) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    var idTokenKey = idToken.generateCredentialKey();\n    this.setItem(idTokenKey, JSON.stringify(idToken));\n  };\n  /**\r\n   * generates accessToken entity from a string\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.getAccessTokenCredential = function (accessTokenKey) {\n    var value = this.getItem(accessTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      return null;\n    }\n    var parsedAccessToken = this.validateAndParseJson(value);\n    if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\n  };\n  /**\r\n   * set accessToken credential to the platform cache\r\n   * @param accessToken\r\n   */\n  BrowserCacheManager.prototype.setAccessTokenCredential = function (accessToken) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    var accessTokenKey = accessToken.generateCredentialKey();\n    this.setItem(accessTokenKey, JSON.stringify(accessToken));\n  };\n  /**\r\n   * generates refreshToken entity from a string\r\n   * @param refreshTokenKey\r\n   */\n  BrowserCacheManager.prototype.getRefreshTokenCredential = function (refreshTokenKey) {\n    var value = this.getItem(refreshTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      return null;\n    }\n    var parsedRefreshToken = this.validateAndParseJson(value);\n    if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\n  };\n  /**\r\n   * set refreshToken credential to the platform cache\r\n   * @param refreshToken\r\n   */\n  BrowserCacheManager.prototype.setRefreshTokenCredential = function (refreshToken) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    var refreshTokenKey = refreshToken.generateCredentialKey();\n    this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n  };\n  /**\r\n   * fetch appMetadata entity from the platform cache\r\n   * @param appMetadataKey\r\n   */\n  BrowserCacheManager.prototype.getAppMetadata = function (appMetadataKey) {\n    var value = this.getItem(appMetadataKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    var parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n  };\n  /**\r\n   * set appMetadata entity to the platform cache\r\n   * @param appMetadata\r\n   */\n  BrowserCacheManager.prototype.setAppMetadata = function (appMetadata) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    var appMetadataKey = appMetadata.generateAppMetadataKey();\n    this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n  };\n  /**\r\n   * fetch server telemetry entity from the platform cache\r\n   * @param serverTelemetryKey\r\n   */\n  BrowserCacheManager.prototype.getServerTelemetry = function (serverTelemetryKey) {\n    var value = this.getItem(serverTelemetryKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    var parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\n  };\n  /**\r\n   * set server telemetry entity to the platform cache\r\n   * @param serverTelemetryKey\r\n   * @param serverTelemetry\r\n   */\n  BrowserCacheManager.prototype.setServerTelemetry = function (serverTelemetryKey, serverTelemetry) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n  };\n  /**\r\n   *\r\n   */\n  BrowserCacheManager.prototype.getAuthorityMetadata = function (key) {\n    var value = this.internalStorage.getItem(key);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n    var parsedMetadata = this.validateAndParseJson(value);\n    if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\n    }\n    return null;\n  };\n  /**\r\n   *\r\n   */\n  BrowserCacheManager.prototype.getAuthorityMetadataKeys = function () {\n    var _this = this;\n    var allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(function (key) {\n      return _this.isAuthorityMetadata(key);\n    });\n  };\n  /**\r\n   * Sets wrapper metadata in memory\r\n   * @param wrapperSKU\r\n   * @param wrapperVersion\r\n   */\n  BrowserCacheManager.prototype.setWrapperMetadata = function (wrapperSKU, wrapperVersion) {\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n  };\n  /**\r\n   * Returns wrapper metadata from in-memory storage\r\n   */\n  BrowserCacheManager.prototype.getWrapperMetadata = function () {\n    var sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\n    var version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\n    return [sku, version];\n  };\n  /**\r\n   *\r\n   * @param entity\r\n   */\n  BrowserCacheManager.prototype.setAuthorityMetadata = function (key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  };\n  /**\r\n   * Gets the active account\r\n   */\n  BrowserCacheManager.prototype.getActiveAccount = function () {\n    var activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    var activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\n    if (!activeAccountValueFilters) {\n      // if new active account cache type isn't found, it's an old version, so look for that instead\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\");\n      var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n      var activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\n      if (!activeAccountValueLocal) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n        return null;\n      }\n      var activeAccount = this.getAccountInfoByFilter({\n        localAccountId: activeAccountValueLocal\n      })[0] || null;\n      if (activeAccount) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\");\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\");\n        this.setActiveAccount(activeAccount);\n        return activeAccount;\n      }\n      return null;\n    }\n    var activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\n    if (activeAccountValueObj) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n      return this.getAccountInfoByFilter({\n        homeAccountId: activeAccountValueObj.homeAccountId,\n        localAccountId: activeAccountValueObj.localAccountId\n      })[0] || null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n    return null;\n  };\n  /**\r\n   * Sets the active account's localAccountId in cache\r\n   * @param account\r\n   */\n  BrowserCacheManager.prototype.setActiveAccount = function (account) {\n    var activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      var activeAccountValue = {\n        homeAccountId: account.homeAccountId,\n        localAccountId: account.localAccountId\n      };\n      this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\n      this.browserStorage.setItem(activeAccountKeyLocal, account.localAccountId);\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountKey);\n      this.browserStorage.removeItem(activeAccountKeyLocal);\n    }\n  };\n  /**\r\n   * Gets a list of accounts that match all of the filters provided\r\n   * @param account\r\n   */\n  BrowserCacheManager.prototype.getAccountInfoByFilter = function (accountFilter) {\n    var allAccounts = this.getAllAccounts();\n    this.logger.trace(\"BrowserCacheManager.getAccountInfoByFilter: total \" + allAccounts.length + \" accounts found\");\n    return allAccounts.filter(function (accountObj) {\n      if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n        return false;\n      }\n      if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\n        return false;\n      }\n      if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\n        return false;\n      }\n      if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\n        return false;\n      }\n      if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\n        return false;\n      }\n      return true;\n    });\n  };\n  /**\r\n   * Checks the cache for accounts matching loginHint or SID\r\n   * @param loginHint\r\n   * @param sid\r\n   */\n  BrowserCacheManager.prototype.getAccountInfoByHints = function (loginHint, sid) {\n    var matchingAccounts = this.getAllAccounts().filter(function (accountInfo) {\n      if (sid) {\n        var accountSid = accountInfo.idTokenClaims && accountInfo.idTokenClaims[\"sid\"];\n        return sid === accountSid;\n      }\n      if (loginHint) {\n        return loginHint === accountInfo.username;\n      }\n      return false;\n    });\n    if (matchingAccounts.length === 1) {\n      return matchingAccounts[0];\n    } else if (matchingAccounts.length > 1) {\n      throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\n    }\n    return null;\n  };\n  /**\r\n   * fetch throttling entity from the platform cache\r\n   * @param throttlingCacheKey\r\n   */\n  BrowserCacheManager.prototype.getThrottlingCache = function (throttlingCacheKey) {\n    var value = this.getItem(throttlingCacheKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    var parsedThrottlingCache = this.validateAndParseJson(value);\n    if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\n  };\n  /**\r\n   * set throttling entity to the platform cache\r\n   * @param throttlingCacheKey\r\n   * @param throttlingCache\r\n   */\n  BrowserCacheManager.prototype.setThrottlingCache = function (throttlingCacheKey, throttlingCache) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n  };\n  /**\r\n   * Gets cache item with given key.\r\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.getTemporaryCache = function (cacheKey, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      var itemCookie = this.getItemCookie(key);\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n    var value = this.temporaryCacheStorage.getItem(key);\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        var item = this.browserStorage.getItem(key);\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  };\n  /**\r\n   * Sets the cache item with the key and value given.\r\n   * Stores in cookie if storeAuthStateInCookie is set to true.\r\n   * This can cause cookie overflow if used incorrectly.\r\n   * @param key\r\n   * @param value\r\n   */\n  BrowserCacheManager.prototype.setTemporaryCache = function (cacheKey, value, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.setItemCookie(key, value);\n    }\n  };\n  /**\r\n   * Removes the cache item with the given key.\r\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.removeItem = function (key) {\n    this.browserStorage.removeItem(key);\n    this.temporaryCacheStorage.removeItem(key);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.clearItemCookie(key);\n    }\n    return true;\n  };\n  /**\r\n   * Checks whether key is in cache.\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.containsKey = function (key) {\n    return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\n  };\n  /**\r\n   * Gets all keys in window.\r\n   */\n  BrowserCacheManager.prototype.getKeys = function () {\n    return __spread(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys());\n  };\n  /**\r\n   * Clears all cache entries created by MSAL.\r\n   */\n  BrowserCacheManager.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Removes all accounts and their credentials\n            return [4 /*yield*/, this.removeAllAccounts()];\n          case 1:\n            // Removes all accounts and their credentials\n            _a.sent();\n            this.removeAppMetadata();\n            // Removes all remaining MSAL cache items\n            this.getKeys().forEach(function (cacheKey) {\n              // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n              if ((_this.browserStorage.containsKey(cacheKey) || _this.temporaryCacheStorage.containsKey(cacheKey)) && (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(_this.clientId) !== -1)) {\n                _this.removeItem(cacheKey);\n              }\n            });\n            this.internalStorage.clear();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Add value to cookies\r\n   * @param cookieName\r\n   * @param cookieValue\r\n   * @param expires\r\n   */\n  BrowserCacheManager.prototype.setItemCookie = function (cookieName, cookieValue, expires) {\n    var cookieStr = encodeURIComponent(cookieName) + \"=\" + encodeURIComponent(cookieValue) + \";path=/;SameSite=Lax;\";\n    if (expires) {\n      var expireTime = this.getCookieExpirationTime(expires);\n      cookieStr += \"expires=\" + expireTime + \";\";\n    }\n    if (this.cacheConfig.secureCookies) {\n      cookieStr += \"Secure;\";\n    }\n    document.cookie = cookieStr;\n  };\n  /**\r\n   * Get one item by key from cookies\r\n   * @param cookieName\r\n   */\n  BrowserCacheManager.prototype.getItemCookie = function (cookieName) {\n    var name = encodeURIComponent(cookieName) + \"=\";\n    var cookieList = document.cookie.split(\";\");\n    for (var i = 0; i < cookieList.length; i++) {\n      var cookie = cookieList[i];\n      while (cookie.charAt(0) === \" \") {\n        cookie = cookie.substring(1);\n      }\n      if (cookie.indexOf(name) === 0) {\n        return decodeURIComponent(cookie.substring(name.length, cookie.length));\n      }\n    }\n    return Constants.EMPTY_STRING;\n  };\n  /**\r\n   * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\r\n   */\n  BrowserCacheManager.prototype.clearMsalCookies = function () {\n    var _this = this;\n    var cookiePrefix = Constants.CACHE_PREFIX + \".\" + this.clientId;\n    var cookieList = document.cookie.split(\";\");\n    cookieList.forEach(function (cookie) {\n      while (cookie.charAt(0) === \" \") {\n        // eslint-disable-next-line no-param-reassign\n        cookie = cookie.substring(1);\n      }\n      if (cookie.indexOf(cookiePrefix) === 0) {\n        var cookieKey = cookie.split(\"=\")[0];\n        _this.clearItemCookie(cookieKey);\n      }\n    });\n  };\n  /**\r\n   * Clear an item in the cookies by key\r\n   * @param cookieName\r\n   */\n  BrowserCacheManager.prototype.clearItemCookie = function (cookieName) {\n    this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);\n  };\n  /**\r\n   * Get cookie expiration time\r\n   * @param cookieLifeDays\r\n   */\n  BrowserCacheManager.prototype.getCookieExpirationTime = function (cookieLifeDays) {\n    var today = new Date();\n    var expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\n    return expr.toUTCString();\n  };\n  /**\r\n   * Gets the cache object referenced by the browser\r\n   */\n  BrowserCacheManager.prototype.getCache = function () {\n    return this.browserStorage;\n  };\n  /**\r\n   * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\r\n   */\n  BrowserCacheManager.prototype.setCache = function () {\n    // sets nothing\n  };\n  /**\r\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n  BrowserCacheManager.prototype.generateCacheKey = function (key) {\n    var generatedKey = this.validateAndParseJson(key);\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n        return key;\n      }\n      return Constants.CACHE_PREFIX + \".\" + this.clientId + \".\" + key;\n    }\n    return JSON.stringify(key);\n  };\n  /**\r\n   * Create authorityKey to cache authority\r\n   * @param state\r\n   */\n  BrowserCacheManager.prototype.generateAuthorityKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.AUTHORITY + \".\" + stateId);\n  };\n  /**\r\n   * Create Nonce key to cache nonce\r\n   * @param state\r\n   */\n  BrowserCacheManager.prototype.generateNonceKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN + \".\" + stateId);\n  };\n  /**\r\n   * Creates full cache key for the request state\r\n   * @param stateString State string for the request\r\n   */\n  BrowserCacheManager.prototype.generateStateKey = function (stateString) {\n    // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.REQUEST_STATE + \".\" + stateId);\n  };\n  /**\r\n   * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n   */\n  BrowserCacheManager.prototype.getCachedAuthority = function (cachedState) {\n    var stateCacheKey = this.generateStateKey(cachedState);\n    var state = this.getTemporaryCache(stateCacheKey);\n    if (!state) {\n      return null;\n    }\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    return this.getTemporaryCache(authorityCacheKey);\n  };\n  /**\r\n   * Updates account, authority, and state in cache\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   */\n  BrowserCacheManager.prototype.updateCacheEntries = function (state, nonce, authorityInstance, loginHint, account) {\n    this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\n    // Cache the request state\n    var stateCacheKey = this.generateStateKey(state);\n    this.setTemporaryCache(stateCacheKey, state, false);\n    // Cache the nonce\n    var nonceCacheKey = this.generateNonceKey(state);\n    this.setTemporaryCache(nonceCacheKey, nonce, false);\n    // Cache authorityKey\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n    if (account) {\n      var ccsCredential = {\n        credential: account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    } else if (!StringUtils.isEmpty(loginHint)) {\n      var ccsCredential = {\n        credential: loginHint,\n        type: CcsCredentialType.UPN\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    }\n  };\n  /**\r\n   * Reset all temporary cache items\r\n   * @param state\r\n   */\n  BrowserCacheManager.prototype.resetRequestCache = function (state) {\n    var _this = this;\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n    // check state and remove associated cache items\n    if (!StringUtils.isEmpty(state)) {\n      this.getKeys().forEach(function (key) {\n        if (key.indexOf(state) !== -1) {\n          _this.removeItem(key);\n        }\n      });\n    }\n    // delete generic interactive request parameters\n    if (state) {\n      this.removeItem(this.generateStateKey(state));\n      this.removeItem(this.generateNonceKey(state));\n      this.removeItem(this.generateAuthorityKey(state));\n    }\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n    this.setInteractionInProgress(false);\n  };\n  /**\r\n   * Removes temporary cache for the provided state\r\n   * @param stateString\r\n   */\n  BrowserCacheManager.prototype.cleanRequestByState = function (stateString) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\n    // Interaction is completed - remove interaction status.\n    if (stateString) {\n      var stateKey = this.generateStateKey(stateString);\n      var cachedState = this.temporaryCacheStorage.getItem(stateKey);\n      this.logger.infoPii(\"BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: \" + cachedState);\n      this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\n    }\n    this.clearMsalCookies();\n  };\n  /**\r\n   * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n   * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n   * @param interactionType\r\n   */\n  BrowserCacheManager.prototype.cleanRequestByInteractionType = function (interactionType) {\n    var _this = this;\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\n    // Loop through all keys to find state key\n    this.getKeys().forEach(function (key) {\n      // If this key is not the state key, move on\n      if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n        return;\n      }\n      // Retrieve state value, return if not a valid value\n      var stateValue = _this.temporaryCacheStorage.getItem(key);\n      if (!stateValue) {\n        return;\n      }\n      // Extract state and ensure it matches given InteractionType, then clean request cache\n      var parsedState = BrowserProtocolUtils.extractBrowserRequestState(_this.cryptoImpl, stateValue);\n      if (parsedState && parsedState.interactionType === interactionType) {\n        _this.logger.infoPii(\"BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: \" + stateValue);\n        _this.resetRequestCache(stateValue);\n      }\n    });\n    this.clearMsalCookies();\n    this.setInteractionInProgress(false);\n  };\n  BrowserCacheManager.prototype.cacheCodeRequest = function (authCodeRequest, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n    var encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n  };\n  /**\r\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n   */\n  BrowserCacheManager.prototype.getCachedRequest = function (state, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n    // Get token request from cache and parse as TokenExchangeParameters.\n    var encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n    if (!encodedTokenRequest) {\n      throw BrowserAuthError.createNoTokenRequestCacheError();\n    }\n    var parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest));\n    if (!parsedRequest) {\n      throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\n    }\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    // Get cached authority and use if no authority is cached with request.\n    if (StringUtils.isEmpty(parsedRequest.authority)) {\n      var authorityCacheKey = this.generateAuthorityKey(state);\n      var cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n      if (!cachedAuthority) {\n        throw BrowserAuthError.createNoCachedAuthorityError();\n      }\n      parsedRequest.authority = cachedAuthority;\n    }\n    return parsedRequest;\n  };\n  /**\r\n   * Gets cached native request for redirect flows\r\n   */\n  BrowserCacheManager.prototype.getCachedNativeRequest = function () {\n    this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n    var cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n    if (!cachedRequest) {\n      this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n      return null;\n    }\n    var parsedRequest = this.validateAndParseJson(cachedRequest);\n    if (!parsedRequest) {\n      this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n      return null;\n    }\n    return parsedRequest;\n  };\n  BrowserCacheManager.prototype.isInteractionInProgress = function (matchClientId) {\n    var clientId = this.getInteractionInProgress();\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  };\n  BrowserCacheManager.prototype.getInteractionInProgress = function () {\n    var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\n    return this.getTemporaryCache(key, false);\n  };\n  BrowserCacheManager.prototype.setInteractionInProgress = function (inProgress) {\n    // Ensure we don't overwrite interaction in progress for a different clientId\n    var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\n    if (inProgress) {\n      if (this.getInteractionInProgress()) {\n        throw BrowserAuthError.createInteractionInProgressError();\n      } else {\n        // No interaction is in progress\n        this.setTemporaryCache(key, this.clientId, false);\n      }\n    } else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\n      this.removeItem(key);\n    }\n  };\n  /**\r\n   * Returns username retrieved from ADAL or MSAL v1 idToken\r\n   */\n  BrowserCacheManager.prototype.getLegacyLoginHint = function () {\n    // Only check for adal/msal token if no SSO params are being used\n    var adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\n    if (adalIdTokenString) {\n      this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n      this.logger.verbose(\"Cached ADAL id token retrieved.\");\n    }\n    // Check for cached MSAL v1 id token\n    var msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\n    if (msalIdTokenString) {\n      this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\n      this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n    }\n    var cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n    if (cachedIdTokenString) {\n      var cachedIdToken = new IdToken(cachedIdTokenString, this.cryptoImpl);\n      if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\n        return cachedIdToken.claims.preferred_username;\n      } else if (cachedIdToken.claims && cachedIdToken.claims.upn) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\n        return cachedIdToken.claims.upn;\n      } else {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\n      }\n    }\n    return null;\n  };\n  /**\r\n   * Updates a credential's cache key if the current cache key is outdated\r\n   */\n  BrowserCacheManager.prototype.updateCredentialCacheKey = function (currentCacheKey, credential) {\n    var updatedCacheKey = credential.generateCredentialKey();\n    if (currentCacheKey !== updatedCacheKey) {\n      var cacheItem = this.getItem(currentCacheKey);\n      if (cacheItem) {\n        this.removeItem(currentCacheKey);\n        this.setItem(updatedCacheKey, cacheItem);\n        this.logger.verbose(\"Updated an outdated \" + credential.credentialType + \" cache key\");\n        return updatedCacheKey;\n      } else {\n        this.logger.error(\"Attempted to update an outdated \" + credential.credentialType + \" cache key but no item matching the outdated key was found in storage\");\n      }\n    }\n    return currentCacheKey;\n  };\n  /**\r\n   * Returns application id as redirect context during AcquireTokenRedirect flow.\r\n   */\n  BrowserCacheManager.prototype.getRedirectRequestContext = function () {\n    return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, true);\n  };\n  /**\r\n   * Sets application id as the redirect context during AcquireTokenRedirect flow.\r\n   * @param value\r\n   */\n  BrowserCacheManager.prototype.setRedirectRequestContext = function (value) {\n    this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, value, true);\n  };\n  return BrowserCacheManager;\n}(CacheManager);\nvar DEFAULT_BROWSER_CACHE_MANAGER = function (clientId, logger) {\n  var cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"names":["__extends","BrowserCacheManager","_super","clientId","cacheConfig","cryptoImpl","logger","_this","call","COOKIE_LIFE_MULTIPLIER","internalStorage","MemoryStorage","browserStorage","setupBrowserStorage","cacheLocation","temporaryCacheStorage","setupTemporaryCacheStorage","migrateCacheEntries","prototype","BrowserCacheLocation","LocalStorage","SessionStorage","BrowserStorage","e","verbose","idTokenKey","Constants","CACHE_PREFIX","PersistentCacheKeys","ID_TOKEN","clientInfoKey","CLIENT_INFO","errorKey","ERROR","errorDescKey","ERROR_DESC","idTokenValue","getItem","clientInfoValue","errorValue","errorDescValue","values","keysToMigrate","forEach","cacheKey","index","migrateCacheEntry","newKey","value","setTemporaryCache","validateAndParseJson","jsonValue","parsedJson","JSON","parse","error","key","setItem","getAccount","accountKey","account","parsedAccount","AccountEntity","isAccountEntity","CacheManager","toObject","setAccount","trace","generateAccountKey","stringify","getIdTokenCredential","parsedIdToken","IdTokenEntity","isIdTokenEntity","setIdTokenCredential","idToken","generateCredentialKey","getAccessTokenCredential","accessTokenKey","parsedAccessToken","AccessTokenEntity","isAccessTokenEntity","setAccessTokenCredential","accessToken","getRefreshTokenCredential","refreshTokenKey","parsedRefreshToken","RefreshTokenEntity","isRefreshTokenEntity","setRefreshTokenCredential","refreshToken","getAppMetadata","appMetadataKey","parsedMetadata","AppMetadataEntity","isAppMetadataEntity","setAppMetadata","appMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetryKey","ServerTelemetryEntity","isServerTelemetryEntity","setServerTelemetry","serverTelemetry","getAuthorityMetadata","AuthorityMetadataEntity","isAuthorityMetadataEntity","getAuthorityMetadataKeys","allKeys","getKeys","filter","isAuthorityMetadata","setWrapperMetadata","wrapperSKU","wrapperVersion","InMemoryCacheKeys","WRAPPER_SKU","WRAPPER_VER","getWrapperMetadata","sku","EMPTY_STRING","version","setAuthorityMetadata","entity","getActiveAccount","activeAccountKeyFilters","generateCacheKey","ACTIVE_ACCOUNT_FILTERS","activeAccountValueFilters","activeAccountKeyLocal","ACTIVE_ACCOUNT","activeAccountValueLocal","activeAccount","getAccountInfoByFilter","localAccountId","setActiveAccount","activeAccountValueObj","homeAccountId","activeAccountKey","activeAccountValue","removeItem","accountFilter","allAccounts","getAllAccounts","length","accountObj","username","toLowerCase","tenantId","environment","getAccountInfoByHints","loginHint","sid","matchingAccounts","accountInfo","accountSid","idTokenClaims","ClientAuthError","createMultipleMatchingAccountsInCacheError","getThrottlingCache","throttlingCacheKey","parsedThrottlingCache","ThrottlingEntity","isThrottlingEntity","setThrottlingCache","throttlingCache","getTemporaryCache","generateKey","storeAuthStateInCookie","itemCookie","getItemCookie","item","setItemCookie","clearItemCookie","containsKey","__spread","clear","removeAllAccounts","_a","sent","removeAppMetadata","indexOf","cookieName","cookieValue","expires","cookieStr","encodeURIComponent","expireTime","getCookieExpirationTime","secureCookies","document","cookie","name","cookieList","split","i","charAt","substring","decodeURIComponent","clearMsalCookies","cookiePrefix","cookieKey","cookieLifeDays","today","Date","expr","getTime","toUTCString","getCache","setCache","generatedKey","StringUtils","startsWith","ADAL_ID_TOKEN","generateAuthorityKey","stateString","stateId","ProtocolUtils","parseRequestState","libraryState","id","TemporaryCacheKeys","AUTHORITY","generateNonceKey","NONCE_IDTOKEN","generateStateKey","REQUEST_STATE","getCachedAuthority","cachedState","stateCacheKey","state","authorityCacheKey","updateCacheEntries","nonce","authorityInstance","nonceCacheKey","ccsCredential","credential","type","CcsCredentialType","HOME_ACCOUNT_ID","CCS_CREDENTIAL","isEmpty","UPN","resetRequestCache","REQUEST_PARAMS","ORIGIN_URI","URL_HASH","CORRELATION_ID","NATIVE_REQUEST","setInteractionInProgress","cleanRequestByState","stateKey","infoPii","cleanRequestByInteractionType","interactionType","stateValue","parsedState","BrowserProtocolUtils","extractBrowserRequestState","cacheCodeRequest","authCodeRequest","browserCrypto","encodedValue","base64Encode","getCachedRequest","encodedTokenRequest","BrowserAuthError","createNoTokenRequestCacheError","parsedRequest","base64Decode","createUnableToParseTokenRequestCacheError","authority","cachedAuthority","createNoCachedAuthorityError","getCachedNativeRequest","cachedRequest","isInteractionInProgress","matchClientId","getInteractionInProgress","INTERACTION_STATUS_KEY","inProgress","createInteractionInProgressError","getLegacyLoginHint","adalIdTokenString","msalIdTokenString","cachedIdTokenString","cachedIdToken","IdToken","claims","preferred_username","upn","updateCredentialCacheKey","currentCacheKey","updatedCacheKey","cacheItem","credentialType","getRedirectRequestContext","REDIRECT_CONTEXT","setRedirectRequestContext","DEFAULT_BROWSER_CACHE_MANAGER","cacheOptions","DEFAULT_CRYPTO_IMPLEMENTATION"],"sources":["/Users/sujal/Desktop/MSAL/msal-react-tutorial/node_modules/@azure/msal-browser/src/cache/BrowserCacheManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants, PersistentCacheKeys, StringUtils, CommonAuthorizationCodeRequest, ICrypto, AccountEntity, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, CacheManager, ServerTelemetryEntity, ThrottlingEntity, ProtocolUtils, Logger, AuthorityMetadataEntity, DEFAULT_CRYPTO_IMPLEMENTATION, AccountInfo, ActiveAccountFilters, CcsCredential, CcsCredentialType, IdToken, ValidCredentialType, ClientAuthError } from \"@azure/msal-common\";\nimport { CacheOptions } from \"../config/Configuration\";\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\nimport { BrowserCacheLocation, InteractionType, TemporaryCacheKeys, InMemoryCacheKeys } from \"../utils/BrowserConstants\";\nimport { BrowserStorage } from \"./BrowserStorage\";\nimport { MemoryStorage } from \"./MemoryStorage\";\nimport { IWindowStorage } from \"./IWindowStorage\";\nimport { BrowserProtocolUtils } from \"../utils/BrowserProtocolUtils\";\nimport { NativeTokenRequest } from \"../broker/nativeBroker/NativeRequest\";\n\n/**\n * This class implements the cache storage interface for MSAL through browser local or session storage.\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\n * parameters such as state and nonce, generally.\n */\nexport class BrowserCacheManager extends CacheManager {\n\n    // Cache configuration, either set by user or default values.\n    protected cacheConfig: Required<CacheOptions>;\n    // Window storage object (either local or sessionStorage)\n    protected browserStorage: IWindowStorage<string>;\n    // Internal in-memory storage object used for data used by msal that does not need to persist across page loads\n    protected internalStorage: MemoryStorage<string>;\n    // Temporary cache\n    protected temporaryCacheStorage: IWindowStorage<string>;\n    // Client id of application. Used in cache keys to partition cache correctly in the case of multiple instances of MSAL.\n    protected logger: Logger;\n\n    // Cookie life calculation (hours * minutes * seconds * ms)\n    protected readonly COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n\n    constructor(clientId: string, cacheConfig: Required<CacheOptions>, cryptoImpl: ICrypto, logger: Logger) {\n        super(clientId, cryptoImpl);\n\n        this.cacheConfig = cacheConfig;\n        this.logger = logger;\n        this.internalStorage = new MemoryStorage();\n        this.browserStorage = this.setupBrowserStorage(this.cacheConfig.cacheLocation);\n        this.temporaryCacheStorage = this.setupTemporaryCacheStorage(this.cacheConfig.cacheLocation);\n\n        // Migrate any cache entries from older versions of MSAL.\n        this.migrateCacheEntries();\n    }\n\n    /**\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\n     * @param cacheLocation\n     */\n    protected setupBrowserStorage(cacheLocation: BrowserCacheLocation | string): IWindowStorage<string> {\n        switch (cacheLocation) {\n            case BrowserCacheLocation.LocalStorage:\n            case BrowserCacheLocation.SessionStorage:\n                try {\n                    // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n                    return new BrowserStorage(cacheLocation);\n                } catch (e) {\n                    this.logger.verbose(e);\n                    break;\n                }\n            case BrowserCacheLocation.MemoryStorage:\n            default:\n                break;\n        }\n        this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n        return new MemoryStorage();\n    }\n\n    /**\n     *\n     * @param cacheLocation\n     */\n    protected setupTemporaryCacheStorage(cacheLocation: BrowserCacheLocation | string): IWindowStorage<string> {\n        switch (cacheLocation) {\n            case BrowserCacheLocation.LocalStorage:\n            case BrowserCacheLocation.SessionStorage:\n                try {\n                    // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n                    return new BrowserStorage(BrowserCacheLocation.SessionStorage);\n                } catch (e) {\n                    this.logger.verbose(e);\n                    return this.internalStorage;\n                }\n            case BrowserCacheLocation.MemoryStorage:\n            default:\n                return this.internalStorage;\n        }\n    }\n\n    /**\n     * Migrate all old cache entries to new schema. No rollback supported.\n     * @param storeAuthStateInCookie\n     */\n    protected migrateCacheEntries(): void {\n        const idTokenKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ID_TOKEN}`;\n        const clientInfoKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.CLIENT_INFO}`;\n        const errorKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR}`;\n        const errorDescKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR_DESC}`;\n\n        const idTokenValue = this.browserStorage.getItem(idTokenKey);\n        const clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n        const errorValue = this.browserStorage.getItem(errorKey);\n        const errorDescValue = this.browserStorage.getItem(errorDescKey);\n\n        const values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n        const keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n\n        keysToMigrate.forEach((cacheKey:string, index: number) => this.migrateCacheEntry(cacheKey, values[index]));\n    }\n\n    /**\n     * Utility function to help with migration.\n     * @param newKey\n     * @param value\n     * @param storeAuthStateInCookie\n     */\n    protected migrateCacheEntry(newKey: string, value: string|null): void {\n        if (value) {\n            this.setTemporaryCache(newKey, value, true);\n        }\n    }\n\n    /**\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\n     * @param input\n     */\n    protected validateAndParseJson(jsonValue: string): object | null {\n        try {\n            const parsedJson = JSON.parse(jsonValue);\n            /**\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\n             *\n             */\n            return (parsedJson && typeof parsedJson === \"object\") ? parsedJson : null;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    /**\n     * fetches the entry from the browser storage based off the key\n     * @param key\n     */\n    getItem(key: string): string | null {\n        return this.browserStorage.getItem(key);\n    }\n\n    /**\n     * sets the entry in the browser storage\n     * @param key\n     * @param value\n     */\n    setItem(key: string, value: string): void {\n        this.browserStorage.setItem(key, value);\n    }\n\n    /**\n     * fetch the account entity from the platform cache\n     * @param accountKey\n     */\n    getAccount(accountKey: string): AccountEntity | null {\n        const account = this.getItem(accountKey);\n        if (!account) {\n            return null;\n        }\n\n        const parsedAccount = this.validateAndParseJson(account);\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n            return null;\n        }\n\n        return CacheManager.toObject<AccountEntity>(new AccountEntity(), parsedAccount);\n    }\n\n    /**\n     * set account entity in the platform cache\n     * @param key\n     * @param value\n     */\n    setAccount(account: AccountEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\n        const key = account.generateAccountKey();\n        this.setItem(key, JSON.stringify(account));\n    }\n\n    /**\n     * generates idToken entity from a string\n     * @param idTokenKey\n     */\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\n        const value = this.getItem(idTokenKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n            return null;\n        }\n\n        const parsedIdToken = this.validateAndParseJson(value);\n        if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n        return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n    }\n\n    /**\n     * set IdToken credential to the platform cache\n     * @param idToken\n     */\n    setIdTokenCredential(idToken: IdTokenEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n        const idTokenKey = idToken.generateCredentialKey();\n\n        this.setItem(idTokenKey, JSON.stringify(idToken));\n    }\n\n    /**\n     * generates accessToken entity from a string\n     * @param key\n     */\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\n        const value = this.getItem(accessTokenKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n            return null;\n        }\n        const parsedAccessToken = this.validateAndParseJson(value);\n        if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n        return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\n    }\n\n    /**\n     * set accessToken credential to the platform cache\n     * @param accessToken\n     */\n    setAccessTokenCredential(accessToken: AccessTokenEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n        const accessTokenKey = accessToken.generateCredentialKey();\n        this.setItem(accessTokenKey, JSON.stringify(accessToken));\n    }\n\n    /**\n     * generates refreshToken entity from a string\n     * @param refreshTokenKey\n     */\n    getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null {\n        const value = this.getItem(refreshTokenKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n            return null;\n        }\n        const parsedRefreshToken = this.validateAndParseJson(value);\n        if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n        return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\n    }\n\n    /**\n     * set refreshToken credential to the platform cache\n     * @param refreshToken\n     */\n    setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n        const refreshTokenKey = refreshToken.generateCredentialKey();\n        this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n    }\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\n        const value = this.getItem(appMetadataKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n            return null;\n        }\n\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n        return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n    }\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n        const appMetadataKey = appMetadata.generateAppMetadataKey();\n        this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n    }\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null {\n        const value = this.getItem(serverTelemetryKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n        return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\n    }\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n        this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadata(key: string) : AuthorityMetadataEntity | null {\n        const value = this.internalStorage.getItem(key);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n            return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\n        }\n        return null;\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadataKeys(): Array<string> {\n        const allKeys = this.internalStorage.getKeys();\n        return allKeys.filter((key) => {\n            return this.isAuthorityMetadata(key);\n        });\n    }\n\n    /**\n     * Sets wrapper metadata in memory\n     * @param wrapperSKU\n     * @param wrapperVersion\n     */\n    setWrapperMetadata(wrapperSKU: string, wrapperVersion: string): void {\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n    }\n\n    /**\n     * Returns wrapper metadata from in-memory storage\n     */\n    getWrapperMetadata(): [string, string] {\n        const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\n        const version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\n        return [sku, version];\n    }\n\n    /**\n     *\n     * @param entity\n     */\n    setAuthorityMetadata(key: string, entity: AuthorityMetadataEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n        this.internalStorage.setItem(key, JSON.stringify(entity));\n    }\n\n    /**\n     * Gets the active account\n     */\n    getActiveAccount(): AccountInfo | null {\n        const activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n        const activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\n        if (!activeAccountValueFilters) {\n            // if new active account cache type isn't found, it's an old version, so look for that instead\n            this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\");\n            const activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n            const activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\n            if(!activeAccountValueLocal) {\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n                return null;\n            }\n            const activeAccount = this.getAccountInfoByFilter({localAccountId: activeAccountValueLocal})[0] || null;\n            if(activeAccount) {\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\");\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\");\n                this.setActiveAccount(activeAccount);\n                return activeAccount;\n            }\n            return null;\n        }\n        const activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters) as AccountInfo;\n        if(activeAccountValueObj) {\n            this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n            return this.getAccountInfoByFilter({\n                homeAccountId: activeAccountValueObj.homeAccountId,\n                localAccountId: activeAccountValueObj.localAccountId\n            })[0] || null;\n        }\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n        return null;\n    }\n\n    /**\n     * Sets the active account's localAccountId in cache\n     * @param account\n     */\n    setActiveAccount(account: AccountInfo | null): void {\n        const activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n        const activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n        if (account) {\n            this.logger.verbose(\"setActiveAccount: Active account set\");\n            const activeAccountValue: ActiveAccountFilters = {\n                homeAccountId: account.homeAccountId,\n                localAccountId: account.localAccountId\n            };\n            this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\n            this.browserStorage.setItem(activeAccountKeyLocal, account.localAccountId);\n        } else {\n            this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n            this.browserStorage.removeItem(activeAccountKey);\n            this.browserStorage.removeItem(activeAccountKeyLocal);\n        }\n    }\n\n    /**\n     * Gets a list of accounts that match all of the filters provided\n     * @param account\n     */\n    getAccountInfoByFilter(accountFilter: Partial<Omit<AccountInfo, \"idTokenClaims\"|\"name\">>): AccountInfo[] {\n        const allAccounts = this.getAllAccounts();\n        this.logger.trace(`BrowserCacheManager.getAccountInfoByFilter: total ${allAccounts.length} accounts found`);\n\n        return allAccounts.filter((accountObj) => {\n            if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n                return false;\n            }\n\n            if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\n                return false;\n            }\n\n            if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\n                return false;\n            }\n\n            if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\n                return false;\n            }\n\n            if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\n                return false;\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Checks the cache for accounts matching loginHint or SID\n     * @param loginHint\n     * @param sid\n     */\n    getAccountInfoByHints(loginHint?: string, sid?: string): AccountInfo | null {\n        const matchingAccounts = this.getAllAccounts().filter((accountInfo) => {\n            if (sid) {\n                const accountSid = accountInfo.idTokenClaims && accountInfo.idTokenClaims[\"sid\"];\n                return sid === accountSid;\n            }\n\n            if (loginHint) {\n                return loginHint === accountInfo.username;\n            }\n\n            return false;\n        });\n\n        if (matchingAccounts.length === 1) {\n            return matchingAccounts[0];\n        } else if (matchingAccounts.length > 1) {\n            throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\n        }\n\n        return null;\n    }\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\n        const value = this.getItem(throttlingCacheKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n            return null;\n        }\n\n        const parsedThrottlingCache = this.validateAndParseJson(value);\n        if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n        return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\n    }\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n        this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n    }\n\n    /**\n     * Gets cache item with given key.\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    getTemporaryCache(cacheKey: string, generateKey?: boolean): string | null {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            const itemCookie = this.getItemCookie(key);\n            if (itemCookie) {\n                this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n                return itemCookie;\n            }\n        }\n\n        const value = this.temporaryCacheStorage.getItem(key);\n        if (!value) {\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\n            if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n                const item = this.browserStorage.getItem(key);\n                if (item) {\n                    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n                    return item;\n                }\n            }\n            this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n            return null;\n        }\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n        return value;\n    }\n\n    /**\n     * Sets the cache item with the key and value given.\n     * Stores in cookie if storeAuthStateInCookie is set to true.\n     * This can cause cookie overflow if used incorrectly.\n     * @param key\n     * @param value\n     */\n    setTemporaryCache(cacheKey: string, value: string, generateKey?: boolean): void {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n\n        this.temporaryCacheStorage.setItem(key, value);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n            this.setItemCookie(key, value);\n        }\n    }\n\n    /**\n     * Removes the cache item with the given key.\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    removeItem(key: string): boolean {\n        this.browserStorage.removeItem(key);\n        this.temporaryCacheStorage.removeItem(key);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n            this.clearItemCookie(key);\n        }\n        return true;\n    }\n\n    /**\n     * Checks whether key is in cache.\n     * @param key\n     */\n    containsKey(key: string): boolean {\n        return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\n    }\n\n    /**\n     * Gets all keys in window.\n     */\n    getKeys(): string[] {\n        return [\n            ...this.browserStorage.getKeys(),\n            ...this.temporaryCacheStorage.getKeys()\n        ];\n    }\n\n    /**\n     * Clears all cache entries created by MSAL.\n     */\n    async clear(): Promise<void> {\n        // Removes all accounts and their credentials\n        await this.removeAllAccounts();\n        this.removeAppMetadata();\n\n        // Removes all remaining MSAL cache items\n        this.getKeys().forEach((cacheKey: string) => {\n            // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n            if ((this.browserStorage.containsKey(cacheKey) || this.temporaryCacheStorage.containsKey(cacheKey)) && ((cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1) || (cacheKey.indexOf(this.clientId) !== -1))) {\n                this.removeItem(cacheKey);\n            }\n        });\n\n        this.internalStorage.clear();\n    }\n\n    /**\n     * Add value to cookies\n     * @param cookieName\n     * @param cookieValue\n     * @param expires\n     */\n    setItemCookie(cookieName: string, cookieValue: string, expires?: number): void {\n        let cookieStr = `${encodeURIComponent(cookieName)}=${encodeURIComponent(cookieValue)};path=/;SameSite=Lax;`;\n        if (expires) {\n            const expireTime = this.getCookieExpirationTime(expires);\n            cookieStr += `expires=${expireTime};`;\n        }\n\n        if (this.cacheConfig.secureCookies) {\n            cookieStr += \"Secure;\";\n        }\n\n        document.cookie = cookieStr;\n    }\n\n    /**\n     * Get one item by key from cookies\n     * @param cookieName\n     */\n    getItemCookie(cookieName: string): string {\n        const name = `${encodeURIComponent(cookieName)}=`;\n        const cookieList = document.cookie.split(\";\");\n        for (let i: number = 0; i < cookieList.length; i++) {\n            let cookie = cookieList[i];\n            while (cookie.charAt(0) === \" \") {\n                cookie = cookie.substring(1);\n            }\n            if (cookie.indexOf(name) === 0) {\n                return decodeURIComponent(cookie.substring(name.length, cookie.length));\n            }\n        }\n        return Constants.EMPTY_STRING;\n    }\n\n    /**\n     * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\n     */\n    clearMsalCookies(): void {\n        const cookiePrefix = `${Constants.CACHE_PREFIX}.${this.clientId}`;\n        const cookieList = document.cookie.split(\";\");\n        cookieList.forEach((cookie: string): void => {\n            while (cookie.charAt(0) === \" \") {\n                // eslint-disable-next-line no-param-reassign\n                cookie = cookie.substring(1);\n            }\n            if (cookie.indexOf(cookiePrefix) === 0) {\n                const cookieKey = cookie.split(\"=\")[0];\n                this.clearItemCookie(cookieKey);\n            }\n        });\n    }\n\n    /**\n     * Clear an item in the cookies by key\n     * @param cookieName\n     */\n    clearItemCookie(cookieName: string): void {\n        this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);\n    }\n\n    /**\n     * Get cookie expiration time\n     * @param cookieLifeDays\n     */\n    getCookieExpirationTime(cookieLifeDays: number): string {\n        const today = new Date();\n        const expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\n        return expr.toUTCString();\n    }\n\n    /**\n     * Gets the cache object referenced by the browser\n     */\n    getCache(): object {\n        return this.browserStorage;\n    }\n\n    /**\n     * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\n     */\n    setCache(): void {\n        // sets nothing\n    }\n\n    /**\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n     * @param key\n     * @param addInstanceId\n     */\n    generateCacheKey(key: string): string {\n        const generatedKey = this.validateAndParseJson(key);\n        if (!generatedKey) {\n            if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n                return key;\n            }\n            return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\n        }\n\n        return JSON.stringify(key);\n    }\n\n    /**\n     * Create authorityKey to cache authority\n     * @param state\n     */\n    generateAuthorityKey(stateString: string): string {\n        const {\n            libraryState: {\n                id: stateId\n            }\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n\n        return this.generateCacheKey(`${TemporaryCacheKeys.AUTHORITY}.${stateId}`);\n    }\n\n    /**\n     * Create Nonce key to cache nonce\n     * @param state\n     */\n    generateNonceKey(stateString: string): string {\n        const {\n            libraryState: {\n                id: stateId\n            }\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n\n        return this.generateCacheKey(`${TemporaryCacheKeys.NONCE_IDTOKEN}.${stateId}`);\n    }\n\n    /**\n     * Creates full cache key for the request state\n     * @param stateString State string for the request\n     */\n    generateStateKey(stateString: string): string {\n        // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n        const {\n            libraryState: {\n                id: stateId\n            }\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n        return this.generateCacheKey(`${TemporaryCacheKeys.REQUEST_STATE}.${stateId}`);\n    }\n\n    /**\n     * Gets the cached authority based on the cached state. Returns empty if no cached state found.\n     */\n    getCachedAuthority(cachedState: string): string | null {\n        const stateCacheKey = this.generateStateKey(cachedState);\n        const state = this.getTemporaryCache(stateCacheKey);\n        if (!state) {\n            return null;\n        }\n\n        const authorityCacheKey = this.generateAuthorityKey(state);\n        return this.getTemporaryCache(authorityCacheKey);\n    }\n\n    /**\n     * Updates account, authority, and state in cache\n     * @param serverAuthenticationRequest\n     * @param account\n     */\n    updateCacheEntries(state: string, nonce: string, authorityInstance: string, loginHint: string, account: AccountInfo|null): void {\n        this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\n        // Cache the request state\n        const stateCacheKey = this.generateStateKey(state);\n        this.setTemporaryCache(stateCacheKey, state, false);\n\n        // Cache the nonce\n        const nonceCacheKey = this.generateNonceKey(state);\n        this.setTemporaryCache(nonceCacheKey, nonce, false);\n\n        // Cache authorityKey\n        const authorityCacheKey = this.generateAuthorityKey(state);\n        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n\n        if (account) {\n            const ccsCredential: CcsCredential = {\n                credential: account.homeAccountId,\n                type: CcsCredentialType.HOME_ACCOUNT_ID\n            };\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n        } else if (!StringUtils.isEmpty(loginHint)) {\n            const ccsCredential: CcsCredential = {\n                credential: loginHint,\n                type: CcsCredentialType.UPN\n            };\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n        }\n    }\n\n    /**\n     * Reset all temporary cache items\n     * @param state\n     */\n    resetRequestCache(state: string): void {\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n        // check state and remove associated cache items\n        if (!StringUtils.isEmpty(state)) {\n            this.getKeys().forEach(key => {\n                if (key.indexOf(state) !== -1) {\n                    this.removeItem(key);\n                }\n            });\n        }\n\n        // delete generic interactive request parameters\n        if (state) {\n            this.removeItem(this.generateStateKey(state));\n            this.removeItem(this.generateNonceKey(state));\n            this.removeItem(this.generateAuthorityKey(state));\n        }\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n        this.setInteractionInProgress(false);\n    }\n\n    /**\n     * Removes temporary cache for the provided state\n     * @param stateString\n     */\n    cleanRequestByState(stateString: string): void {\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\n        // Interaction is completed - remove interaction status.\n        if (stateString) {\n            const stateKey = this.generateStateKey(stateString);\n            const cachedState = this.temporaryCacheStorage.getItem(stateKey);\n            this.logger.infoPii(`BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: ${cachedState}`);\n            this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\n        }\n        this.clearMsalCookies();\n    }\n\n    /**\n     * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\n     * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\n     * @param interactionType\n     */\n    cleanRequestByInteractionType(interactionType: InteractionType): void {\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\n        // Loop through all keys to find state key\n        this.getKeys().forEach((key) => {\n            // If this key is not the state key, move on\n            if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n                return;\n            }\n\n            // Retrieve state value, return if not a valid value\n            const stateValue = this.temporaryCacheStorage.getItem(key);\n            if (!stateValue) {\n                return;\n            }\n            // Extract state and ensure it matches given InteractionType, then clean request cache\n            const parsedState = BrowserProtocolUtils.extractBrowserRequestState(this.cryptoImpl, stateValue);\n            if (parsedState && parsedState.interactionType === interactionType) {\n                this.logger.infoPii(`BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: ${stateValue}`);\n                this.resetRequestCache(stateValue);\n            }\n        });\n        this.clearMsalCookies();\n        this.setInteractionInProgress(false);\n    }\n\n    cacheCodeRequest(authCodeRequest: CommonAuthorizationCodeRequest, browserCrypto: ICrypto): void {\n        this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n\n        const encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\n        this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n    }\n\n    /**\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\n     */\n    getCachedRequest(state: string, browserCrypto: ICrypto): CommonAuthorizationCodeRequest {\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n        // Get token request from cache and parse as TokenExchangeParameters.\n        const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n        if (!encodedTokenRequest) {\n            throw BrowserAuthError.createNoTokenRequestCacheError();\n        }\n\n        const parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest)) as CommonAuthorizationCodeRequest;\n        if (!parsedRequest) {\n            throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\n        }\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n\n        // Get cached authority and use if no authority is cached with request.\n        if (StringUtils.isEmpty(parsedRequest.authority)) {\n            const authorityCacheKey: string = this.generateAuthorityKey(state);\n            const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n            if (!cachedAuthority) {\n                throw BrowserAuthError.createNoCachedAuthorityError();\n            }\n            parsedRequest.authority = cachedAuthority;\n        }\n\n        return parsedRequest;\n    }\n\n    /**\n     * Gets cached native request for redirect flows\n     */\n    getCachedNativeRequest(): NativeTokenRequest | null {\n        this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n        const cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n        if (!cachedRequest) {\n            this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n            return null;\n        }\n\n        const parsedRequest = this.validateAndParseJson(cachedRequest) as NativeTokenRequest;\n        if (!parsedRequest) {\n            this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n            return null;\n        }\n\n        return parsedRequest;\n    }\n\n    isInteractionInProgress(matchClientId?: boolean): boolean {\n        const clientId = this.getInteractionInProgress();\n\n        if (matchClientId) {\n            return clientId === this.clientId;\n        } else {\n            return !!clientId;\n        }\n    }\n\n    getInteractionInProgress(): string | null {\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        return this.getTemporaryCache(key, false);\n    }\n\n    setInteractionInProgress(inProgress: boolean): void {\n        // Ensure we don't overwrite interaction in progress for a different clientId\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        if (inProgress) {\n            if (this.getInteractionInProgress()) {\n                throw BrowserAuthError.createInteractionInProgressError();\n            } else {\n                // No interaction is in progress\n                this.setTemporaryCache(key, this.clientId, false);\n            }\n        } else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\n            this.removeItem(key);\n        }\n    }\n\n    /**\n     * Returns username retrieved from ADAL or MSAL v1 idToken\n     */\n    getLegacyLoginHint(): string | null {\n        // Only check for adal/msal token if no SSO params are being used\n        const adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\n        if (adalIdTokenString) {\n            this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n            this.logger.verbose(\"Cached ADAL id token retrieved.\");\n        }\n\n        // Check for cached MSAL v1 id token\n        const msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\n        if (msalIdTokenString) {\n            this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\n            this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n        }\n\n        const cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n        if (cachedIdTokenString) {\n            const cachedIdToken = new IdToken(cachedIdTokenString, this.cryptoImpl);\n            if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\n                return cachedIdToken.claims.preferred_username;\n            }\n            else if (cachedIdToken.claims && cachedIdToken.claims.upn) {\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\n                return cachedIdToken.claims.upn;\n            }\n            else {\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Updates a credential's cache key if the current cache key is outdated\n     */\n    updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string {\n        const updatedCacheKey = credential.generateCredentialKey();\n\n        if (currentCacheKey !== updatedCacheKey) {\n            const cacheItem = this.getItem(currentCacheKey);\n            if (cacheItem) {\n                this.removeItem(currentCacheKey);\n                this.setItem(updatedCacheKey, cacheItem);\n                this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);\n                return updatedCacheKey;\n            } else {\n                this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);\n            }\n        }\n\n        return currentCacheKey;\n    }\n\n    /**\n     * Returns application id as redirect context during AcquireTokenRedirect flow.\n     */\n    getRedirectRequestContext(): string | null {\n        return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, true);\n    }\n\n    /**\n     * Sets application id as the redirect context during AcquireTokenRedirect flow.\n     * @param value\n     */\n    setRedirectRequestContext(value: string): void {\n        this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, value, true);\n    }\n}\n\nexport const DEFAULT_BROWSER_CACHE_MANAGER = (clientId: string, logger: Logger): BrowserCacheManager => {\n    const cacheOptions = {\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\n        storeAuthStateInCookie: false,\n        secureCookies: false\n    };\n    return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}