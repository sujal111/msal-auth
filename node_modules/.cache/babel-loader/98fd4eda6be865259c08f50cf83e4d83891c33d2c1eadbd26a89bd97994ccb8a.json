{"ast":null,"code":"/*! @azure/msal-browser v2.34.0 2023-03-07 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { UrlString, Constants, PerformanceEvents, AuthorizationCodeClient, Authority, AuthorityFactory, ResponseMode, StringUtils, ProtocolUtils } from '@azure/msal-common';\nimport { BaseInteractionClient } from './BaseInteractionClient.js';\nimport { BrowserConstants } from '../utils/BrowserConstants.js';\nimport { version } from '../packageMetadata.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';\nimport { BrowserUtils } from '../utils/BrowserUtils.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Defines the class structure and helper functions used by the \"standard\", non-brokered auth flows (popup, redirect, silent (RT), silent (iframe))\r\n */\nvar StandardInteractionClient = /** @class */function (_super) {\n  __extends(StandardInteractionClient, _super);\n  function StandardInteractionClient() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Generates an auth code request tied to the url request.\r\n   * @param request\r\n   */\n  StandardInteractionClient.prototype.initializeAuthorizationCodeRequest = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var generatedPkceParams, authCodeRequest;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);\n            this.logger.verbose(\"initializeAuthorizationRequest called\", request.correlationId);\n            return [4 /*yield*/, this.browserCrypto.generatePkceCodes()];\n          case 1:\n            generatedPkceParams = _a.sent();\n            authCodeRequest = __assign(__assign({}, request), {\n              redirectUri: request.redirectUri,\n              code: Constants.EMPTY_STRING,\n              codeVerifier: generatedPkceParams.verifier\n            });\n            request.codeChallenge = generatedPkceParams.challenge;\n            request.codeChallengeMethod = Constants.S256_CODE_CHALLENGE_METHOD;\n            return [2 /*return*/, authCodeRequest];\n        }\n      });\n    });\n  };\n  /**\r\n   * Initializer for the logout request.\r\n   * @param logoutRequest\r\n   */\n  StandardInteractionClient.prototype.initializeLogoutRequest = function (logoutRequest) {\n    this.logger.verbose(\"initializeLogoutRequest called\", logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.correlationId);\n    var validLogoutRequest = __assign({\n      correlationId: this.correlationId || this.browserCrypto.createNewGuid()\n    }, logoutRequest);\n    /**\r\n     * Set logout_hint to be login_hint from ID Token Claims if present\r\n     * and logoutHint attribute wasn't manually set in logout request\r\n     */\n    if (logoutRequest) {\n      // If logoutHint isn't set and an account was passed in, try to extract logoutHint from ID Token Claims\n      if (!logoutRequest.logoutHint) {\n        if (logoutRequest.account) {\n          var logoutHint = this.getLogoutHintFromIdTokenClaims(logoutRequest.account);\n          if (logoutHint) {\n            this.logger.verbose(\"Setting logoutHint to login_hint ID Token Claim value for the account provided\");\n            validLogoutRequest.logoutHint = logoutHint;\n          }\n        } else {\n          this.logger.verbose(\"logoutHint was not set and account was not passed into logout request, logoutHint will not be set\");\n        }\n      } else {\n        this.logger.verbose(\"logoutHint has already been set in logoutRequest\");\n      }\n    } else {\n      this.logger.verbose(\"logoutHint will not be set since no logout request was configured\");\n    }\n    /*\r\n     * Only set redirect uri if logout request isn't provided or the set uri isn't null.\r\n     * Otherwise, use passed uri, config, or current page.\r\n     */\n    if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {\n      if (logoutRequest && logoutRequest.postLogoutRedirectUri) {\n        this.logger.verbose(\"Setting postLogoutRedirectUri to uri set on logout request\", validLogoutRequest.correlationId);\n        validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(logoutRequest.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\n      } else if (this.config.auth.postLogoutRedirectUri === null) {\n        this.logger.verbose(\"postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect\", validLogoutRequest.correlationId);\n      } else if (this.config.auth.postLogoutRedirectUri) {\n        this.logger.verbose(\"Setting postLogoutRedirectUri to configured uri\", validLogoutRequest.correlationId);\n        validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\n      } else {\n        this.logger.verbose(\"Setting postLogoutRedirectUri to current page\", validLogoutRequest.correlationId);\n        validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(BrowserUtils.getCurrentUri(), BrowserUtils.getCurrentUri());\n      }\n    } else {\n      this.logger.verbose(\"postLogoutRedirectUri passed as null, not setting post logout redirect uri\", validLogoutRequest.correlationId);\n    }\n    return validLogoutRequest;\n  };\n  /**\r\n   * Parses login_hint ID Token Claim out of AccountInfo object to be used as\r\n   * logout_hint in end session request.\r\n   * @param account\r\n   */\n  StandardInteractionClient.prototype.getLogoutHintFromIdTokenClaims = function (account) {\n    var idTokenClaims = account.idTokenClaims;\n    if (idTokenClaims) {\n      if (idTokenClaims.login_hint) {\n        return idTokenClaims.login_hint;\n      } else {\n        this.logger.verbose(\"The ID Token Claims tied to the provided account do not contain a login_hint claim, logoutHint will not be added to logout request\");\n      }\n    } else {\n      this.logger.verbose(\"The provided account does not contain ID Token Claims, logoutHint will not be added to logout request\");\n    }\n    return null;\n  };\n  /**\r\n   * Creates an Authorization Code Client with the given authority, or the default authority.\r\n   * @param serverTelemetryManager\r\n   * @param authorityUrl\r\n   */\n  StandardInteractionClient.prototype.createAuthCodeClient = function (serverTelemetryManager, authorityUrl, requestAzureCloudOptions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var clientConfig;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.correlationId);\n            // Create auth module.\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId);\n            return [4 /*yield*/, this.getClientConfiguration(serverTelemetryManager, authorityUrl, requestAzureCloudOptions)];\n          case 1:\n            clientConfig = _a.sent();\n            return [2 /*return*/, new AuthorizationCodeClient(clientConfig, this.performanceClient)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates a Client Configuration object with the given request authority, or the default authority.\r\n   * @param serverTelemetryManager\r\n   * @param requestAuthority\r\n   * @param requestCorrelationId\r\n   */\n  StandardInteractionClient.prototype.getClientConfiguration = function (serverTelemetryManager, requestAuthority, requestAzureCloudOptions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var discoveredAuthority, logger;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId);\n            this.logger.verbose(\"getClientConfiguration called\", this.correlationId);\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);\n            return [4 /*yield*/, this.getDiscoveredAuthority(requestAuthority, requestAzureCloudOptions)];\n          case 1:\n            discoveredAuthority = _a.sent();\n            logger = this.config.system.loggerOptions;\n            return [2 /*return*/, {\n              authOptions: {\n                clientId: this.config.auth.clientId,\n                authority: discoveredAuthority,\n                clientCapabilities: this.config.auth.clientCapabilities\n              },\n              systemOptions: {\n                tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,\n                preventCorsPreflight: true\n              },\n              loggerOptions: {\n                loggerCallback: logger.loggerCallback,\n                piiLoggingEnabled: logger.piiLoggingEnabled,\n                logLevel: logger.logLevel,\n                correlationId: this.correlationId\n              },\n              cryptoInterface: this.browserCrypto,\n              networkInterface: this.networkClient,\n              storageInterface: this.browserStorage,\n              serverTelemetryManager: serverTelemetryManager,\n              libraryInfo: {\n                sku: BrowserConstants.MSAL_SKU,\n                version: version,\n                cpu: Constants.EMPTY_STRING,\n                os: Constants.EMPTY_STRING\n              },\n              telemetry: this.config.telemetry\n            }];\n        }\n      });\n    });\n  };\n  /**\r\n   * @param hash\r\n   * @param interactionType\r\n   */\n  StandardInteractionClient.prototype.validateAndExtractStateFromHash = function (serverParams, interactionType, requestCorrelationId) {\n    this.logger.verbose(\"validateAndExtractStateFromHash called\", requestCorrelationId);\n    if (!serverParams.state) {\n      throw BrowserAuthError.createHashDoesNotContainStateError();\n    }\n    var platformStateObj = BrowserProtocolUtils.extractBrowserRequestState(this.browserCrypto, serverParams.state);\n    if (!platformStateObj) {\n      throw BrowserAuthError.createUnableToParseStateError();\n    }\n    if (platformStateObj.interactionType !== interactionType) {\n      throw BrowserAuthError.createStateInteractionTypeMismatchError();\n    }\n    this.logger.verbose(\"Returning state from hash\", requestCorrelationId);\n    return serverParams.state;\n  };\n  /**\r\n   * Used to get a discovered version of the default authority.\r\n   * @param requestAuthority\r\n   * @param requestCorrelationId\r\n   */\n  StandardInteractionClient.prototype.getDiscoveredAuthority = function (requestAuthority, requestAzureCloudOptions) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var getAuthorityMeasurement, authorityOptions, userAuthority, builtAuthority;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);\n            this.logger.verbose(\"getDiscoveredAuthority called\", this.correlationId);\n            getAuthorityMeasurement = (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.startMeasurement(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);\n            authorityOptions = {\n              protocolMode: this.config.auth.protocolMode,\n              knownAuthorities: this.config.auth.knownAuthorities,\n              cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n              authorityMetadata: this.config.auth.authorityMetadata,\n              skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache\n            };\n            userAuthority = requestAuthority ? requestAuthority : this.config.auth.authority;\n            builtAuthority = Authority.generateAuthority(userAuthority, requestAzureCloudOptions || this.config.auth.azureCloudOptions);\n            this.logger.verbose(\"Creating discovered authority with configured authority\", this.correlationId);\n            this.performanceClient.setPreQueueTime(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, this.correlationId);\n            return [4 /*yield*/, AuthorityFactory.createDiscoveredInstance(builtAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions, this.logger, this.performanceClient, this.correlationId).then(function (result) {\n              getAuthorityMeasurement.endMeasurement({\n                success: true\n              });\n              return result;\n            }).catch(function (error) {\n              getAuthorityMeasurement.endMeasurement({\n                errorCode: error.errorCode,\n                subErrorCode: error.subError,\n                success: false\n              });\n              throw error;\n            })];\n          case 1:\n            return [2 /*return*/, _b.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Helper to initialize required request parameters for interactive APIs and ssoSilent()\r\n   * @param request\r\n   * @param interactionType\r\n   */\n  StandardInteractionClient.prototype.initializeAuthorizationRequest = function (request, interactionType) {\n    return __awaiter(this, void 0, void 0, function () {\n      var redirectUri, browserState, state, validatedRequest, _a, account, legacyLoginHint;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.correlationId);\n            this.logger.verbose(\"initializeAuthorizationRequest called\", this.correlationId);\n            redirectUri = this.getRedirectUri(request.redirectUri);\n            browserState = {\n              interactionType: interactionType\n            };\n            state = ProtocolUtils.setRequestState(this.browserCrypto, request && request.state || Constants.EMPTY_STRING, browserState);\n            this.performanceClient.setPreQueueTime(PerformanceEvents.InitializeBaseRequest, this.correlationId);\n            _a = [{}];\n            return [4 /*yield*/, this.initializeBaseRequest(request)];\n          case 1:\n            validatedRequest = __assign.apply(void 0, [__assign.apply(void 0, _a.concat([_b.sent()])), {\n              redirectUri: redirectUri,\n              state: state,\n              nonce: request.nonce || this.browserCrypto.createNewGuid(),\n              responseMode: ResponseMode.FRAGMENT\n            }]);\n            account = request.account || this.browserStorage.getActiveAccount();\n            if (account) {\n              this.logger.verbose(\"Setting validated request account\", this.correlationId);\n              this.logger.verbosePii(\"Setting validated request account: \" + account.homeAccountId, this.correlationId);\n              validatedRequest.account = account;\n            }\n            // Check for ADAL/MSAL v1 SSO\n            if (StringUtils.isEmpty(validatedRequest.loginHint) && !account) {\n              legacyLoginHint = this.browserStorage.getLegacyLoginHint();\n              if (legacyLoginHint) {\n                validatedRequest.loginHint = legacyLoginHint;\n              }\n            }\n            return [2 /*return*/, validatedRequest];\n        }\n      });\n    });\n  };\n  return StandardInteractionClient;\n}(BaseInteractionClient);\nexport { StandardInteractionClient };","map":{"version":3,"names":["__extends","StandardInteractionClient","_super","prototype","initializeAuthorizationCodeRequest","request","performanceClient","addQueueMeasurement","PerformanceEvents","StandardInteractionClientInitializeAuthorizationCodeRequest","correlationId","logger","verbose","browserCrypto","generatePkceCodes","generatedPkceParams","_a","sent","authCodeRequest","__assign","redirectUri","code","Constants","EMPTY_STRING","codeVerifier","verifier","codeChallenge","challenge","codeChallengeMethod","S256_CODE_CHALLENGE_METHOD","initializeLogoutRequest","logoutRequest","validLogoutRequest","createNewGuid","logoutHint","account","getLogoutHintFromIdTokenClaims","postLogoutRedirectUri","UrlString","getAbsoluteUrl","BrowserUtils","getCurrentUri","config","auth","idTokenClaims","login_hint","createAuthCodeClient","serverTelemetryManager","authorityUrl","requestAzureCloudOptions","StandardInteractionClientCreateAuthCodeClient","setPreQueueTime","StandardInteractionClientGetClientConfiguration","getClientConfiguration","clientConfig","AuthorizationCodeClient","requestAuthority","StandardInteractionClientGetDiscoveredAuthority","getDiscoveredAuthority","discoveredAuthority","system","loggerOptions","authOptions","clientId","authority","clientCapabilities","systemOptions","tokenRenewalOffsetSeconds","preventCorsPreflight","loggerCallback","piiLoggingEnabled","logLevel","cryptoInterface","networkInterface","networkClient","storageInterface","browserStorage","libraryInfo","sku","BrowserConstants","MSAL_SKU","version","cpu","os","telemetry","validateAndExtractStateFromHash","serverParams","interactionType","requestCorrelationId","state","BrowserAuthError","createHashDoesNotContainStateError","platformStateObj","BrowserProtocolUtils","extractBrowserRequestState","createUnableToParseStateError","createStateInteractionTypeMismatchError","getAuthorityMeasurement","startMeasurement","authorityOptions","protocolMode","knownAuthorities","cloudDiscoveryMetadata","authorityMetadata","skipAuthorityMetadataCache","userAuthority","builtAuthority","Authority","generateAuthority","azureCloudOptions","AuthorityFactoryCreateDiscoveredInstance","AuthorityFactory","createDiscoveredInstance","then","result","endMeasurement","success","catch","error","errorCode","subErrorCode","subError","_b","initializeAuthorizationRequest","StandardInteractionClientInitializeAuthorizationRequest","getRedirectUri","browserState","ProtocolUtils","setRequestState","InitializeBaseRequest","initializeBaseRequest","validatedRequest","apply","concat","nonce","responseMode","ResponseMode","FRAGMENT","getActiveAccount","verbosePii","homeAccountId","StringUtils","isEmpty","loginHint","legacyLoginHint","getLegacyLoginHint","BaseInteractionClient"],"sources":["/Users/sujal/Desktop/MSAL/msal-react-tutorial/node_modules/@azure/msal-browser/src/interaction_client/StandardInteractionClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ServerTelemetryManager, CommonAuthorizationCodeRequest, Constants, AuthorizationCodeClient, ClientConfiguration, AuthorityOptions, Authority, AuthorityFactory, ServerAuthorizationCodeResponse, UrlString, CommonEndSessionRequest, ProtocolUtils, ResponseMode, StringUtils, IdTokenClaims, AccountInfo, AzureCloudOptions, PerformanceEvents, AuthError} from \"@azure/msal-common\";\nimport { BaseInteractionClient } from \"./BaseInteractionClient\";\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\nimport { BrowserConstants, InteractionType } from \"../utils/BrowserConstants\";\nimport { version } from \"../packageMetadata\";\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\nimport { BrowserProtocolUtils, BrowserStateObject } from \"../utils/BrowserProtocolUtils\";\nimport { EndSessionRequest } from \"../request/EndSessionRequest\";\nimport { BrowserUtils } from \"../utils/BrowserUtils\";\nimport { RedirectRequest } from \"../request/RedirectRequest\";\nimport { PopupRequest } from \"../request/PopupRequest\";\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest\";\n\n/**\n * Defines the class structure and helper functions used by the \"standard\", non-brokered auth flows (popup, redirect, silent (RT), silent (iframe))\n */\nexport abstract class StandardInteractionClient extends BaseInteractionClient {\n    /**\n     * Generates an auth code request tied to the url request.\n     * @param request\n     */\n    protected async initializeAuthorizationCodeRequest(request: AuthorizationUrlRequest): Promise<CommonAuthorizationCodeRequest> {\n        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);\n        this.logger.verbose(\"initializeAuthorizationRequest called\", request.correlationId);\n        const generatedPkceParams = await this.browserCrypto.generatePkceCodes();\n\n        const authCodeRequest: CommonAuthorizationCodeRequest = {\n            ...request,\n            redirectUri: request.redirectUri,\n            code: Constants.EMPTY_STRING,\n            codeVerifier: generatedPkceParams.verifier\n        };\n\n        request.codeChallenge = generatedPkceParams.challenge;\n        request.codeChallengeMethod = Constants.S256_CODE_CHALLENGE_METHOD;\n\n        return authCodeRequest;\n    }\n\n    /**\n     * Initializer for the logout request.\n     * @param logoutRequest\n     */\n    protected initializeLogoutRequest(logoutRequest?: EndSessionRequest): CommonEndSessionRequest {\n        this.logger.verbose(\"initializeLogoutRequest called\", logoutRequest?.correlationId);\n\n        const validLogoutRequest: CommonEndSessionRequest = {\n            correlationId: this.correlationId || this.browserCrypto.createNewGuid(),\n            ...logoutRequest\n        };\n\n        /**\n         * Set logout_hint to be login_hint from ID Token Claims if present\n         * and logoutHint attribute wasn't manually set in logout request\n         */\n        if (logoutRequest) {\n            // If logoutHint isn't set and an account was passed in, try to extract logoutHint from ID Token Claims\n            if (!logoutRequest.logoutHint) {\n                if(logoutRequest.account) {\n                    const logoutHint = this.getLogoutHintFromIdTokenClaims(logoutRequest.account);\n                    if (logoutHint) {\n                        this.logger.verbose(\"Setting logoutHint to login_hint ID Token Claim value for the account provided\");\n                        validLogoutRequest.logoutHint = logoutHint;\n                    }\n                } else {\n                    this.logger.verbose(\"logoutHint was not set and account was not passed into logout request, logoutHint will not be set\");\n                }\n            } else {\n                this.logger.verbose(\"logoutHint has already been set in logoutRequest\");\n            }\n        } else {\n            this.logger.verbose(\"logoutHint will not be set since no logout request was configured\");\n        }\n\n        /*\n         * Only set redirect uri if logout request isn't provided or the set uri isn't null.\n         * Otherwise, use passed uri, config, or current page.\n         */\n        if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {\n            if (logoutRequest && logoutRequest.postLogoutRedirectUri) {\n                this.logger.verbose(\"Setting postLogoutRedirectUri to uri set on logout request\", validLogoutRequest.correlationId);\n                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(logoutRequest.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\n            } else if (this.config.auth.postLogoutRedirectUri === null) {\n                this.logger.verbose(\"postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect\", validLogoutRequest.correlationId);\n            } else if (this.config.auth.postLogoutRedirectUri) {\n                this.logger.verbose(\"Setting postLogoutRedirectUri to configured uri\", validLogoutRequest.correlationId);\n                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\n            } else {\n                this.logger.verbose(\"Setting postLogoutRedirectUri to current page\", validLogoutRequest.correlationId);\n                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(BrowserUtils.getCurrentUri(), BrowserUtils.getCurrentUri());\n            }\n        } else {\n            this.logger.verbose(\"postLogoutRedirectUri passed as null, not setting post logout redirect uri\", validLogoutRequest.correlationId);\n        }\n\n        return validLogoutRequest;\n    }\n\n    /**\n     * Parses login_hint ID Token Claim out of AccountInfo object to be used as\n     * logout_hint in end session request.\n     * @param account\n     */\n    protected getLogoutHintFromIdTokenClaims(account: AccountInfo): string | null {\n        const idTokenClaims: IdTokenClaims | undefined = account.idTokenClaims;\n        if (idTokenClaims) {\n            if (idTokenClaims.login_hint) {\n                return idTokenClaims.login_hint;\n            } else {\n                this.logger.verbose(\"The ID Token Claims tied to the provided account do not contain a login_hint claim, logoutHint will not be added to logout request\");\n            }\n        } else {\n            this.logger.verbose(\"The provided account does not contain ID Token Claims, logoutHint will not be added to logout request\");\n        }\n\n        return null;\n    }\n\n    /**\n     * Creates an Authorization Code Client with the given authority, or the default authority.\n     * @param serverTelemetryManager\n     * @param authorityUrl\n     */\n    protected async createAuthCodeClient(serverTelemetryManager: ServerTelemetryManager, authorityUrl?: string, requestAzureCloudOptions?: AzureCloudOptions): Promise<AuthorizationCodeClient> {\n        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.correlationId);\n        // Create auth module.\n        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId);\n        const clientConfig = await this.getClientConfiguration(serverTelemetryManager, authorityUrl, requestAzureCloudOptions);\n        return new AuthorizationCodeClient(clientConfig, this.performanceClient);\n    }\n\n    /**\n     * Creates a Client Configuration object with the given request authority, or the default authority.\n     * @param serverTelemetryManager\n     * @param requestAuthority\n     * @param requestCorrelationId\n     */\n    protected async getClientConfiguration(serverTelemetryManager: ServerTelemetryManager, requestAuthority?: string, requestAzureCloudOptions?: AzureCloudOptions): Promise<ClientConfiguration> {\n        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId);\n        this.logger.verbose(\"getClientConfiguration called\", this.correlationId);\n        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);\n        const discoveredAuthority = await this.getDiscoveredAuthority(requestAuthority, requestAzureCloudOptions);\n        const logger= this.config.system.loggerOptions;\n\n        return {\n            authOptions: {\n                clientId: this.config.auth.clientId,\n                authority: discoveredAuthority,\n                clientCapabilities: this.config.auth.clientCapabilities\n            },\n            systemOptions: {\n                tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,\n                preventCorsPreflight: true\n            },\n            loggerOptions: {\n                loggerCallback: logger.loggerCallback,\n                piiLoggingEnabled: logger.piiLoggingEnabled,\n                logLevel: logger.logLevel,\n                correlationId: this.correlationId\n            },\n            cryptoInterface: this.browserCrypto,\n            networkInterface: this.networkClient,\n            storageInterface: this.browserStorage,\n            serverTelemetryManager: serverTelemetryManager,\n            libraryInfo: {\n                sku: BrowserConstants.MSAL_SKU,\n                version: version,\n                cpu: Constants.EMPTY_STRING,\n                os: Constants.EMPTY_STRING\n            },\n            telemetry: this.config.telemetry\n        };\n    }\n    \n    /**\n     * @param hash\n     * @param interactionType\n     */\n    protected validateAndExtractStateFromHash(serverParams: ServerAuthorizationCodeResponse, interactionType: InteractionType, requestCorrelationId?: string): string {\n        this.logger.verbose(\"validateAndExtractStateFromHash called\", requestCorrelationId);\n        if (!serverParams.state) {\n            throw BrowserAuthError.createHashDoesNotContainStateError();\n        }\n\n        const platformStateObj = BrowserProtocolUtils.extractBrowserRequestState(this.browserCrypto, serverParams.state);\n        if (!platformStateObj) {\n            throw BrowserAuthError.createUnableToParseStateError();\n        }\n\n        if (platformStateObj.interactionType !== interactionType) {\n            throw BrowserAuthError.createStateInteractionTypeMismatchError();\n        }\n\n        this.logger.verbose(\"Returning state from hash\", requestCorrelationId);\n        return serverParams.state;\n    }\n\n    /**\n     * Used to get a discovered version of the default authority.\n     * @param requestAuthority\n     * @param requestCorrelationId\n     */\n    protected async getDiscoveredAuthority(requestAuthority?: string, requestAzureCloudOptions?: AzureCloudOptions): Promise<Authority> {\n        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);\n        this.logger.verbose(\"getDiscoveredAuthority called\", this.correlationId);\n        const getAuthorityMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);\n        const authorityOptions: AuthorityOptions = {\n            protocolMode: this.config.auth.protocolMode,\n            knownAuthorities: this.config.auth.knownAuthorities,\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n            authorityMetadata: this.config.auth.authorityMetadata,\n            skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache\n        };\n\n        // build authority string based on auth params, precedence - azureCloudInstance + tenant >> authority\n        const userAuthority = requestAuthority ? requestAuthority : this.config.auth.authority;\n\n        // fall back to the authority from config\n        const builtAuthority = Authority.generateAuthority(userAuthority, requestAzureCloudOptions || this.config.auth.azureCloudOptions);\n        this.logger.verbose(\"Creating discovered authority with configured authority\", this.correlationId);\n        this.performanceClient.setPreQueueTime(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, this.correlationId);\n        return await AuthorityFactory.createDiscoveredInstance(builtAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions, this.logger, this.performanceClient, this.correlationId)\n            .then((result: Authority) => {\n                getAuthorityMeasurement.endMeasurement({\n                    success: true,\n                });\n\n                return result;\n            })\n            .catch((error:AuthError) => {\n                getAuthorityMeasurement.endMeasurement({\n                    errorCode: error.errorCode,\n                    subErrorCode: error.subError,\n                    success: false\n                });\n\n                throw error;\n            });\n    }\n\n    /**\n     * Helper to initialize required request parameters for interactive APIs and ssoSilent()\n     * @param request\n     * @param interactionType\n     */\n    protected async initializeAuthorizationRequest(request: RedirectRequest|PopupRequest|SsoSilentRequest, interactionType: InteractionType): Promise<AuthorizationUrlRequest> {\n        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.correlationId);\n        this.logger.verbose(\"initializeAuthorizationRequest called\", this.correlationId);\n        const redirectUri = this.getRedirectUri(request.redirectUri);\n        const browserState: BrowserStateObject = {\n            interactionType: interactionType\n        };\n        const state = ProtocolUtils.setRequestState(\n            this.browserCrypto,\n            (request && request.state)|| Constants.EMPTY_STRING,\n            browserState\n        );\n\n        this.performanceClient.setPreQueueTime(PerformanceEvents.InitializeBaseRequest, this.correlationId);\n        const validatedRequest: AuthorizationUrlRequest = {\n            ...await this.initializeBaseRequest(request),\n            redirectUri: redirectUri,\n            state: state,\n            nonce: request.nonce || this.browserCrypto.createNewGuid(),\n            responseMode: ResponseMode.FRAGMENT\n        };\n\n        const account = request.account || this.browserStorage.getActiveAccount();\n        if (account) {\n            this.logger.verbose(\"Setting validated request account\", this.correlationId);\n            this.logger.verbosePii(`Setting validated request account: ${account.homeAccountId}`, this.correlationId);\n            validatedRequest.account = account;\n        }\n\n        // Check for ADAL/MSAL v1 SSO\n        if (StringUtils.isEmpty(validatedRequest.loginHint) && !account) {\n            const legacyLoginHint = this.browserStorage.getLegacyLoginHint();\n            if (legacyLoginHint) {\n                validatedRequest.loginHint = legacyLoginHint;\n            }\n        }\n\n        return validatedRequest;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}